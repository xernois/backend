# Easy backend

This project is a basic nodejs "framework" to ease the creation of advanced api, directly based on the nodejs http server.
I am working alone and during my free time on this project, but if you are interrested in this project don't mind contacting me or create a pull request ğŸ˜‰.

## Features

- Server
- controller/route
- resolvers
- services
- middlewares

### ğŸ–¥ï¸ Server

Servers are just instances so you can easily create a server and configure it to use the right source files

```js
import app from "@xernois/easy-backend";

const server = app({
  appFolder: "src", // the folder containing controllers, middlewares and services
});

server.listen(3000, () => {
  // 3000 being an arbitrary port you can change to any port yo want o user
  console.log("Server started on port 3000"); // this message will be logged once the server is listening on port 3000
});
```

> PS: this means that you can easily create multiple server instance listening on differents ports.

### ğŸ§­ controller/route

Controllers are classes that contains one ore more route and it can have a default path affecting all it's routes.

```js
import { Controller, Method, Response, Request, Route } from '@xernois/easy-backend';
import UserResolver from '../resolvers/UserResolver';

@Controller({ path: '/main' }) // default path for every route /main
export default class MainController {

  // a route matching GET /main/user/*
  @Route({ path: '/user/:user', method: [Method.GET], name: 'dynamic', resolvers: { 'user': UserResolver } })
  public dynamic(req: Request, res: Response) {

    res.end(req.data?.['user']) // send back the user data to the client

  }
}
```

Above is an example of a simple controller but with a default path `/main` (this is optional). This controller has only one route, a route is defined by a path, a list of method, a name and a handler. In the example the path `/user/:user` means that it will match any url like `/main/user/test`, `/main/user/123` or `/main/user/1_b_r` and that the variable part of the url will be accessible via a variable with the same name in the request params object `req.params?.['user']`. Handler takes two arguments, the request and the response, these are just the normal objects from nodejs but slightly enhanced, see the [nodeJs doc](https://nodejs.org/api/http.html#class-httpincomingmessage).

The last thing that you may have noticed is the resolver the resolver is use to resolve data as the route is accessed, in the example above, when eccessing the url `/main/user/1` it will get datas for the user with id one and give acces to these data inside the handler. The users data can be found under `req.data?.['user']` object.

> PS: Note that the resoler key must be the same as the variable in the path.

### ğŸ” Resolvers

A resolver is a class that implement the IResolver interface and therefor the resolve method wich take the url variable as a parameter and return modified data.

```js
import { Resolver, IResolver } from "@xernois/easy-backend";
import MainService from "../services/mainService";

@Resolver({singleton: false})
// singleton parameter otional, but it only mean that an instance will be created for each access attemp on any of the routes using this resolver
export default class UserResolver implements IResolver<string> {

    constructor(
        private mainService: MainService // injecting the service that contains our data
    ) { }

    resolve(userID?: string): string { // Signature may vary but the method is mandatory on a resolver.
        // return the users data
        return this.mainService.getUserByID(userID);
    }
}
```

Resolvers are not meant to held datas but just to acces thoses and ease the usage of controllers. But you can completly avoid resolver and inject a service in yor controller to access all your datas directly from the route handler.

### ğŸ—ƒï¸ services

Services are object that are meant to access/manipulate datas from a database or any data source.

```js
import { Injectable } from "@xernois/easy-backend";

@Injectable()
export default class dataService {
  constructor() {}

  data: number[] = [];

  getAndAdd() {
    this.data.push(Math.random()); // add a random number to the array

    return this.data; // return the random number and all random number that were previusly generated by other getAndAdd calls
  }
}
```

there is nothing really specific to services except that these are singletons. this mean that everytime you use the dataService (just an example) it will always be the same instance. That's why storing the arry directly on the service is working.

### ğŸ›¡ï¸ Middlewares

Middlewares are juste here to alter or block request before the handler, it can be use for authentification, to restrict access to specific routes for example. It can be applied to a specific route or directly on a controller.

```js
import { Controller, Method, Response, Request, Route } from '@xernois/easy-backend';
import UserResolver from '../resolvers/UserResolver';
import LoggerMiddleware from '../middlewares/loggerMiddleware';

@Controller({ path: '/main', middlewares: [LoggerMiddleware] })
export default class MainController {

  @Route({ path: '/user/:user', method: [Method.GET], name: 'dynamic', resolvers: { 'user': UserResolver } })
  public dynamic(req: Request, res: Response) {

    res.end(req.data?.['user'])

  }
}
```

in this example the LoggerMiddleware is applied on the controller, this mean it will effect all routes of this controller (in this case only one).

```js
import { Request, Response, Middleware, IMiddleware } from "@xernois/easy-backend";

@Middleware({ singleton: false })
export default class LoggerMiddleware implements IMiddleware {

        execute(req: Request, res: Response) { 
                console.log(req.method, req.url, req.headers.host, req.headers['user-agent'])
        }
}
```

Middlewares implements the IMiddleware interface and the execute method wich is basically a handler. In this case, the middleware is just logging every request method, url, host and user-agent.

## ğŸ“‚ Structure

There are no specific rules for file structure even if I would propbably advise user to use the example structure 
```
â”‚   index.ts
â”‚
â””â”€â”€â”€src
    â”œâ”€â”€â”€controllers
    â”‚       mainController.ts
    â”‚
    â”œâ”€â”€â”€middlewares
    â”‚       loggerMiddleware.ts
    â”‚
    â”œâ”€â”€â”€resolvers
    â”‚       UserResolver.ts
    â”‚
    â””â”€â”€â”€services
            dataService.ts
            mainService.ts
            secondService.ts
```
But at this point it's really a question of preferences and also the size of the project.

## ğŸ Getting started

ğŸš§ Comming soon

## âŒ› Work in progress

- [ ] warn and prevent crash due to circular dependencies

- [ ] Improve les logs
- [ ] verbosity as a server config
- [ ] Serve static file